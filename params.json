{
  "name": "Verstka-tasks-1",
  "tagline": "Задача к лекции «HTML, I часть» – «Вёрстка поста»",
  "body": " </html>\r\n +<!DOCTYPE html>\r\n +<html lang=\"ru\">\r\n +<head>\r\n +    <meta charset=\"utf-8\">\r\n +</head>\r\n +<body bgcolor=\"#d3d3d3\">\r\n +<font face=\"Arial\">\r\n +    <p>Блог компании Яндекс.</p>\r\n +    <p>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</p>\r\n +    <p>Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,<br />\r\n +        какой он красивый, ни то, какой он удобный. Никому не понравится, когда все<br />\r\n +        тормозит. Мы регулярно добавляем в Яндекс.Почту новую функциональность,<br />\r\n +        иногда &mdash; исправляем ошибки, а это значит, у нас постоянно появляются новый код<br />\r\n +        и новая логика. Всё это напрямую влияет на скорость работы интерфейса.</p>\r\n +    <p>Что мы измеряем</p>\r\n +    <p>Этапы первой загрузки:<br />\r\n +        * подготовка;<br />\r\n +        * загрузка статики (HTTP-запрос и парсинг);<br />\r\n +        * исполнение модулей;<br />* инициализация базовых объектов;<br />\r\n +        * отрисовка.</p>\r\n +    <p>Этапы отрисовки любой страницы:<br />\r\n +        * подготовка к запросу на сервер;<br />\r\n +        * запрос данных с сервера;<br />\r\n +        * шаблонизация;<br />\r\n +        * обновление DOM.</p>\r\n +    <p>- &laquo;Ок, теперь у нас есть метрики, мы можем отправить их на сервер&raquo; - говорим мы<br />\r\n +        - &laquo;Что же дальше?&raquo; - вопрошаете вы<br />\r\n +        - &laquo;А давай построим график!&raquo; - отвечаем мы<br />\r\n +        - &laquo;А что будем считать?&raquo; - уточняете вы</p>\r\n +    <p>Как вы знаете, медиана &ndash; это серединное, а не среднее значение в выборке.<br />\r\n +        Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана &ndash; 3, а среднее &ndash; 6,5.<br />\r\n +        В общем случае медиана отлично показывает, сколько грузится средний пользователь.</p>\r\n +    <p>В случае ускорения или замедления медиана, конечно, изменится. Но она не может<br/>\r\n +        рассказать, сколько пользователей ускорилось, а сколько замедлилось.</p>\r\n +    <p>APDEX &ndash; метрика, которая сразу говорит: хорошо или плохо. Метрика<br />\r\n +        работает очень просто. Мы выбираем временной интервал [0; t], такой, что если<br />\r\n +        время показа страницы попало в него, то пользователь счастлив. Берем еще один<br />\r\n +        интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница<br />\r\n +        показана за это время, то пользователь в целом удовлетворен скоростью работы,<br />\r\n +        но уже не настолько счастлив. И применяем формулу:</p>\r\n +    <p>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br />\r\n +        Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br />\r\n +        хорошо или плохо работает почта.</p>\r\n +    <p>Как мы измеряем</p>\r\n +    <p>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять<br />\r\n +        причину замедления: медленнее стал отвечать сервер либо слишком долго<br />\r\n +        выполняется JavaScript. Выглядит это примерно так:</p>\r\n +    <p><code>this.timings['look-ma-im-start'] = Date.now();</code><br />\r\n +        <code>this.timings['look-ma-finish'] = Date.now();</code></p>\r\n +    <p>C помощью Date.now() мы получаем текущее время. Все тайминги собираются и при<br />\r\n +        отправке рассчитываются. На этапах разница между &ldquo;end&rdquo; и &ldquo;start&rdquo; не считается,<br />\r\n +        а все вычисления производятся в конце:</p>\r\n +    <p>var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</p>\r\n +    <p>И на сервер прилетают подобные записи:</p>\r\n +    <p>serverResponse=50&amp;domUpdate=60</p>\r\n +    <p>Как мы ускоряем</p>\r\n +    <p>Чтобы снизить время загрузки почты при выходе новых версий, <br />мы уже делаем следующее:</p>\r\n +    <p>* включаем gzip;<br />\r\n +        * выставляем заголовки кэширования;<br />\r\n +        * фризим CSS, JS, шаблоны и картинки;<br />\r\n +        * используем CDN;</p>\r\n +    <p>Мы подумали: &laquo;А что если хранить где-то старую версию файлов, а при выходе новой<br/>\r\n +        передавать только diff между ней и той, которая сохранена у пользователя?&raquo;<br />\r\n +        В браузере же останется просто наложить патч на клиенте.</p>\r\n +    <p>На самое деле эта идея не нова. Уже существуют стандарты для HTTP &mdash; например,<br />\r\n +        RFC 3229 &laquo;Delta encoding in HTTP&raquo; и &laquo;Google SDHC&raquo;, &mdash; но по разным причинам они<br />\r\n +        не получили должного распространения в браузерах и на серверах.</p>\r\n +    <p>Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,<br />\r\n +        начали искать реализации diff на JS. На популярных хостингах кода нашли<br />\r\n +        библиотеки:<br />\r\n +        - VCDiff<br />\r\n +        - google-diff-patch-match</p>\r\n +    <p>Для окончательного выбора библиотеки нам нужно сравнить:</p>\r\n +    <p><pre>\r\n +Библиотека  | IE  9  | Opera 12</pre>\r\n +    <pre>----------  | ----   | --------</pre>\r\n +    <pre>vcdiff      | 8      | 5</pre>\r\n +    <pre>google diff | 1363   | 76</pre>\r\n +    <p>После того как мы определились с библиотекой для диффа, нужно определиться с тем,<br />где и как хранить статику на клиенте.</p>\r\n +    <p>Формат файла с патчами для проекта выглядит так:<br />\r\n +        [  <br />\r\n +        {  <br />\r\n +        \"k\": \"jane.css\",  <br />\r\n +        \"p\": [patch],  <br />\r\n +        \"s\": 4554  <br />\r\n +        },  <br />\r\n +        {  <br />\r\n +        \"k\": \"jane.css\",  <br />\r\n +        \"p\": [patch],  <br />\r\n +        \"s\": 4554  <br />\r\n +        }  <br />\r\n +        ]</p>\r\n +    <p>То есть это обычный массив из объектов. Каждый объект &mdash; отдельный ресурс. У  <br/>\r\n +        каждого объекта есть три свойства. k &mdash; названия ключа в localStorage для этого  <br />\r\n +        ресурса. p &mdash; патч для ресурса, который сгенерировал vcdiff. s &mdash; чексумма для<br/>\r\n +        ресурса актуальной версии, чтобы потом можно было проверить правильность  <br />\r\n +        наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.</p>\r\n +    <a href=\"https://camo.githubusercontent.com/87655e52351caf112734f0d172ed084113d43a96/68747470733a2f2f696d672d666f746b692e79616e6465782e72752f6765742f31353438372f33323136373634382e302f305f3133333437665f33343966363138615f58354c\" target=\"_blank\">\r\n +        <img src=\"https://camo.githubusercontent.com/87655e52351caf112734f0d172ed084113d43a96/68747470733a2f2f696d672d666f746b692e79616e6465782e72752f6765742f31353438372f33323136373634382e302f305f3133333437665f33343966363138615f58354c\" width=\"400\"\r\n +             style=\"max-width:100%;\"></a>\r\n +    <p>Алгоритм Бройдена &mdash; Флетчера &mdash; Гольдфарба &mdash; Шанно (BFGS)  <br />\r\n +        &mdash; итерационный метод численной оптимизации, предназначенный для  <br />\r\n +        нахождения локального максимума/минимума нелинейного функционала  <br />\r\n +        без ограничений.</p>\r\n +    <p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:  <br />\r\n +        CRC16/32 - алгоритм нахождения контрольной суммы, предназначенный для проверки  <br />\r\n +        целостности данных <br />\r\n +        md5 - 128-битный алгоритм хеширования. Предназначен для создания &laquo;отпечатков&raquo;<br/>\r\n +        или дайджестов сообщения произвольной длины и последующей проверки  <br />\r\n +        их подлинности.</p>\r\n +    <p>Потому что он быстрый, компактный и легок в реализации.</p>\r\n +    <p>Итог</p>\r\n +    <p>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</p>\r\n +    <p><pre> Релиз | С патчем | Без патча\r\n +  <br />7.7.20 | 397      | 174 549\r\n +  <br />7.7.21 | 383      | 53 995\r\n +  <br />7.7.22 | 483      | 3 995</pre> </p>\r\n +    <p>Автор: @doochik  <br />\r\n +        С++ разработик  <br />\r\n +        Электронная почта: (doochik@yandex-team.ru)  <br />\r\n +        Компания: Яндекс</p>\r\n +    <p>Комментарии (3):</p>\r\n +    <p>- Mogaika (mogaika@yandex-team.ru) 30 ноября 2014 в 17:05</p>\r\n +    <p>А можете привести сравнение, на сколько быстрее грузится lite версия?</p>\r\n +    <p>- JIguse (mrawesome@yandex.ru) 29 ноября 2014 в 21:30</p>\r\n +    <p>Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми  <br />\r\n +        подробностями о внутренней работе сервисов.</p>\r\n +    <p>- Brister (brist89@yandex-team.ru) 24 ноября 2014 в 13:13</p>\r\n +    <p>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).  <br />\r\n +        Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,  <br />\r\n +        хорошо или плохо работает почта.</p>\r\n +    <p>наверное все-таки от 0.5 до 1</p>\r\n +    <p>- alexeimois (test@yandex.ru) 22 ноября 2014 в 17:35</p>\r\n +    <p>Мы измеряем скорость загрузки с помощью Яндекс.Метрики:  <br />\r\n +        help.yandex.ru/metrika/reports/monitoring_timing.xml</p>\r\n +    <p>&copy; Яндекс, help@yandex.ru, Хохрякова, 10.</p>\r\n +</font>\r\n +</body>\r\n +</html> ",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}